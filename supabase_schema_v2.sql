-- UPDATED SCHEMA --

-- Enable Profile RLS policies (reiterated)
alter table profiles enable row level security;

-- Add 'role' column if not exists (or stick to user_type, but 'role' is better for logic)
-- We will use 'user_type' ('Individual', 'Lawyer', etc) from previous step, but let's formalize a separate table for verified lawyers.

CREATE TABLE lawyer_profiles (
  id bigint generated by default as identity primary key,
  clerk_id text not null unique references profiles(clerk_id) on delete cascade,
  bar_council_id text,
  specialization text[], -- Array of strings e.g. ['Family', 'Criminal']
  experience_years integer,
  bio text,
  verification_status text default 'pending', -- pending, verified, rejected
  consultation_fee integer, -- numeric value
  rating numeric default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for lawyer_profiles
alter table lawyer_profiles enable row level security;

create policy "Lawyer profiles are viewable by everyone."
  on lawyer_profiles for select
  using ( true );

create policy "Lawyers can update their own profile."
  on lawyer_profiles for update
  using ( clerk_id = auth.uid()::text ); 
  -- Note: auth.uid() relies on Supabase Auth. Since we use Clerk, we generally handle this logic in API or use a custom claim. 
  -- For this demo, we can perform checks in the application layer or allow public insert/update if we trust the client (not recommended for prod).
  -- Better approach for this demo:
  
create policy "Enable insert for authenticated users only" 
  on lawyer_profiles for insert 
  with check (true);

-- DOCUMENTS TABLE (Optional: if we want to store user uploads)
create table documents (
  id bigint generated by default as identity primary key,
  user_id text not null, -- Clerk ID
  file_url text not null,
  file_name text,
  file_type text,
  summary text,
  extracted_text text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- CHAT HISTORY TABLES
create table if not exists chat_sessions (
  id uuid default gen_random_uuid() primary key,
  user_id text not null, -- Clerk ID
  title text default 'New Chat',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists chat_messages (
  id uuid default gen_random_uuid() primary key,
  session_id uuid references chat_sessions(id) on delete cascade not null,
  role text not null, -- 'user' or 'assistant'
  content text,
  meta_data jsonb, -- For structured responses
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);
-- TRACKING USER PROGRESS ON RIGHTS
create table if not exists user_rights_progress (
  id bigint generated by default as identity primary key,
  user_id text not null, -- Clerk ID
  right_id text not null,
  right_title text, -- Fallback if ID changes
  category text,
  status text default 'completed', -- 'in_progress', 'completed'
  completed_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, right_id)
);

-- RLS for progress
alter table user_rights_progress enable row level security;

create policy "Users can view own progress"
  on user_rights_progress for select
  using ( user_id = auth.uid()::text );

create policy "Users can insert/update own progress"
  on user_rights_progress for insert
  with check ( user_id = auth.uid()::text );

create policy "Users can update own progress"
  on user_rights_progress for update
  using ( user_id = auth.uid()::text );
